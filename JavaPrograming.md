## Do it 자바 프로그래밍 정리

- 프로그래밍이란 컴퓨터에게 일을 하도록 명령어를 만드는 것을 칭한다.
- 컴파일: 프로그램 언어를 컴퓨터가 알 수 있는 언어로 바꿔 주는 일
- 컴파일러: 기계어로 번역해주는 프로그램, 자바를 설치하면 자바 컴파일러 또한 설치 된다.

## HelloWorld 출력하기

- first 패키지의 HelloWorld 클래스 생성

 package first;

 public class HelloWorld {

   public static void main(String{} args){
       System.out.println("Hello, World");

    }
}

## 변수와 자료형

- 숫자를 10진수와 8진수, 16진수로 표현 하는법

package chapter2
public class BinaryTest{
    public static void mian(String[] args){

      int num = 10; // 10진수
      int bNum = 0B1010; // 2진수
      int oNum = 012; // 8진수
      int hNum = 0XA; // 16진수

      System.out.println(num); // 10
      System.out.println(bNum); // 10
      System.out.println(oNum); // 10
      System.out.println(hNum); // 10

    }
}

- 음의 정수를 표현하는 방법은 
  가장 왼쪽에 존재하는 부호 비트를 확인한다.
  MSB(Most Significant Bit)
- 음수를 만드는 방법은 그 수에대한 2의 보수를 취함.

 ## 변수와 자료형

 - 프로그래밍에서 값을 사용하기 위해 선언하는 것을 변수하고 함.
 
 - 변수의 이름은 알파벳과 숫자,_,$로 구성됨.
   
   대소문자를 구분한다.
   
   변수의 이름은 숫자로 시작할 수 없고, 키워드도 변수의 이름으로 사용불가
   
   이름사이에 공백이 있을 수 없다.
   
   * 변수의 이름을 정할 때는 변수의 역할에 어울리는 의미있는 이름으로 지어야 한다.

 - 자료형에는 정수형과 문자형, 실수형, 논리형이 존재한다.

 - 바이트 크기별로 나누어진 byte(1) short(2) int(4) long(8)이 정수형
   문자형인 char(2) 실수형인 float(4), double(8) 마지막으로 논리형인
   boolean(1) //()는 바이트의 수를 나타냄.
 
 ## 여러 가지 연산자

 - 자바의 여러가지 연산자에는 산술 연산자, 증가 감소 연산자, 복합
   대입 연산자, 논리 연산자, 비트 연산자, 조건 연산자가 존재한다.

 ## 제어 흐름

 - 조건문 : 주어진 조건에 따라 다른 수행문이 실행 되도록 프로그래밍 함

 - 형식 : if(조건){실행문;} 
          else {실행문;}
 
 - 여러 조건문을 중첩 사용할 수 있지만 코드의 가독성과 효율을 위해
   조건식의 결과가 정수나 문자열의 값이고 이 값에따라 수행문이 결정될 경우에 switch-case문을 활용할 수 있다.

 - switch()
    case 1 : ~~ = ' ' ;
        break; --- 만일 break를 해주지 않으면 다음 문장까지 실행됨.
    case 2 : ~~ = ' ' ;
        break;
    default : ~~ = ' ' ;

## 제어 흐름 2

- 반복문 : 주어진 조건이 만족 할 때까지 수행문을 반복적으로 수행한다.
          while, do-while, for 문이 존재하며 조건의 만족과 반복 가능
          여부에 대해 정확한 코딩을 해야한다.

- while : while(조건식){수행문;} 형태로 조건식이 참인 동안 수행한다.

- do - while : while문과 비슷한 맥락이지만 while문은 처음부터 조건을
  검사하고 그 후에 실행하기 때문에 먼저 수행이 이루어져야 할 경우에는 
  do - while문을 사용한다.

- for : 주로 조건이 횟수인 경우에 사용하며 초기화, 조건, 증감식을
        한번에 작성한다. if(초기화식; 조건식; 증감식){수행문;}

- 반복문 또한 내부에 반복문을 중첩 사용할 수 있다.

- continue : 반복문과 함께 쓰이며, 내부에 continue를 만나면 이후의
             반복되는 부분을 수행하지 않고 조건식이나 증감식을 수행한다.

- break : 반복문에서 만나게 되면 더 이상 반복을 수행하지 않고 빠져나오며
          중첩된 반복문 내부에 존재하는 경우는 가장 가까운 반복문에서 빠져나오게 된다.

## 클래스와 객체 1

- 객체란 의사나 행위가 미치는 대상으로 구체적, 추상적 데이터 단위를 나타낸다.
  객체의 속성에는 특성, 속성, 멤버 변수
  객체의 기능은 객체가 하는 기능을 메소드로 구현한다.

- 클래스란 객체에 대한 속성과 기능을 코드로 구현한 것이다.
  클래스의 정의방법은 
    (접근제어자)class 클래스이름{
        멤버 변수;
        메소드;
  }
  클래스를 학생으로 예를 든다면 속성에는 학번, 이름, 학년 등이 들어가며
  기능에는 수강신청, 수업듣기, 시험 응시 등이 포함된다.

- 클래스는 대부분 대문자로 시작하며 여러개의 클래스가 하나의 자바 파일에 있는 경우
  public 클래스는 단 하나여야 하며, public 클래스와 자바 파일의 이름이 같아야 한다.

## 클래스와 객체 2

- 메소드 : 함수의 일종으로 객체의 기능을 제공하기 위해 클래스 내부에 구현되는 함수

- 함수 : 하나의 기능을 수행하는 일련의 코드로 중복되는 기능을 함수로 구현하여
         호출하여 사용한다.

- 함수 정의하기 : 함수를 코드로 구현할때는 이름, 매개변수, 반환 값을 선언하고 구현
  int add (int num1, int num2){
    int result;
    result = num1 + num2;
    return result;
  } // 덧셈 기능을 가진 함수 선언하기

## 클래스와 객체 3

- 클래스를 사용하기 위해서는 클래스를 생성해야 한다. new 예약러를 이용하여 생성함
  클래스형 변수이름 = new 생성자;
  Student studentA = new Student();

- 인스턴스와 힙(Heap)메모리 : 하나의 클래스 코드로 부터 여러 개의 인스터스를 생성
  하게 되는데 인스턴스는 힙 메모리에 생성되며 각각의 인스턴스는 다른 메모리에 다른
  값을 갖진다.

- 용어 정리
객체 : 객체 지향 프로그램의 대상, 생성된 인스턴스
클래스 : 객체를 프로그래밍하기 위해 코드로 만든 상태
인스턴스 : 클래스가 메모리에 생성된 상태
멤버 변수 : 클래스의 속성, 특성
메소드 : 멤버 변수를 이용하여 클래스의 기능을 구현
참조 변수 : 메모리에 생성된 인스턴스를 가리키는 변수
참조 값 : 생성된 인스턴스의 메모리 주소 값

- 생성자 : 생성자의 기본 문법은 
  <modifiers> <class_name>([<argument_list>]){
    [<statements>]
  } 
  생성자는 인스턴스를 초기화 할 때의 명령어 집합으로 클래스의 이름과 같다.
  또한 메소드가 아니며, 상속되지 않고 리턴값이 존재하지 않는다.

- 디폴트 생성자 : 하나의 클래스에는 적어도 하나 이상의 생성자가 존재해야하며
  직접적으로 생성자를 기술하지 않으면 매개 변수와 구현부가 없는 디폴트 생성자가
  자동으로 생성된다. 만약 클래스에 매개 변수가 있는 생성자를 추가하면 디폴트
  생성자는 제공되지 않는다.

- 생성자 오버로드 : 필요에 의해 생성자를 추가하는 경우 여러 개의 생성자가 
  하나의 클래스에 있을 수 있다.

## 클래스와 객체 4

- 참조 자료형 : 참조 자료형에는 변수의 자료형으로 기본 바료형과 참조 자료형이 존재

- 정보 은닉 : private 접근 제어자로 클래스의 외부에서 클래스의 내부의 멤버 변수나
  메소드에 접근 하지 못하게 하는 경우 사용한다. 오류를 줄일 수 있다.

- this : 자신의 메모리를 가르킴, 생성자에서 다른 생성자를 호출하고 자신의 주소를
  반환한다.

- 생성자에서 다른 생성자를 호출하는 경우
  public Person (){
    this("이름없음",1);
  }
  public Person(String name, int age){
    this.name = name;
    this.age = age;
  }

  ## 클래스와 객체

  - static : 여러개의 인스턴스가 같은 메모리의 값을 공유하기 위해 사용하는 변수

  - 프로그램이 메모리에 로드될때 공간을 할당받아 생성됨. (상수, 리터럴, 스태틱)

  - 따라서 인스턴스의 생성과 관계없이 클래스 이름으로 직접 참조 한다.

  - static 변수의 예 : 여러 인스턴스가 하나의 메모리 값을 공유 할 때 필요
    학생이 생성될 때마다 학번이 증가해야 하는 경우, 기준이 되는 값을 static변수
    를 사용하여 유지한다.

  - static 메소드 : 클래스 매소드 라고도 한다. 매소드에 static 키워드를 사용해 구현
    인스터스 변수를 사용할 수 없으며 인스턴스의 생성과 관계없이 클래스 이름으로
    직접 메소드를 호출한다. ex) Student.getSerialNum(); 일때 getSerialNum()이 
    static 메소드이다. 

  - 인스턴스의 변수의 경우 인스턴스가 먼저 생성되어야 하므로 static 메소드에서는
    생성이 불확실한 인스턴스 변수를 사용할 수 없다.

  - 변수의 유효 범위

    1. 지역 변수(로컬 변수)
      선언 위치 : 함수 내부에 선언
      사용 범위 : 함수 내부에서만 사용
      메모리 : 스택
      생성과 소멸 : 함수가  호출될 때 생성되고 함수가 끝나면 소멸한다.

    
    2. 멤버 변수
      선언 위치 : 클래스 멤버 변수로 선언
      사용 범위 : 클래스 내부에서 사용하고 private이 아닐경우 다른클래스 사용가능
      메모리 : 힙
      생성과 소멸 : 인스턴스가 생성될 때 힙에 생성되고 가비지 컬렉터가 수거하며 소멸

     3. static 변수
      선언 위치 : static 예약어를 사용하여 클래스 내부에 선언
      사용 범위 : 클래스 내부에서 사용하고 private이 아닐경우 다른클래스 사용가능
      메모리 : 데이터 영역
      생성과 소멸 : 프로그램이 처음 시작할 때 상수와 함께 데이터 영역에 생성되며
                  끝나고 메모리를 해제할 때 소멸된다.

  ## 배열과 ArrayList

  - 배열을 사용하는 이유 : 동일한 자료형의 변수를 한꺼번에 순차적으로 관리할 수 있다.

  - 배열 사용하기 : [ ] 인덱스 혹은 첨자 연산자, 배열의 위치를 지정하여 자료를 부름
    모든 배열의 순서는 0 부터 시작함. n개의 배열은 0 ~ n-1의 위치까지 자료가 존재.

  - 배열의 길이의 속성은 length 이며 자료가 있는 요소만 출력하려면 크기에 대한
    저장을 따로 해야한다.

  - 참조 자료형을 선언하는 객체 배열이 존재하며 각 요소를 new를 활용하여 생성, 저장

  - 배열의 복사는 System.out.arraycopy(src, srcPos, dest, destPos, length);
    src: 복사할 배열 이름 srcPos: 복사할 배열의 첫 번째 위치
    dest: 복사해서 붙여 넣을 대상 배열 이름 destPos: 복사해서 대상 배열에 붙여넣기를
    시작할 첫 번째 위치 length: src에서 dest로 자료를 복사할 요소 개수

  - 객체 배열에서의 복사는 기본적으로 그 배열의 값을 복사하는 것이 아니라 
    메모리의 위치 값을 복사하기 때문에 기존 배열의 정보가 바뀌면 복사한 배열의
    값 또한 바뀌게 된다. 따라서 보존하기 위해서는 새로운 인스턴스를 생성하여 
    깊은 복사를 해야만 한다.

## 다차원 배열

- 2차원 이상의 배열로 지도, 게임 등 평면이나 공간을 구현할 때 많이 사용한다.

- 선언과 초기화 
  int[][] arr = new int[i][j]; - i행 j열의 배열이 생성된다.
  int[][] arr ={{1,2,3}, {4,5,6}}; 

- 다차원 배열의 length는 행의 길이를 참조한다.

## ArrayList 클래스

- 기존의 배열은 길이를 정하여 선언한다. 따라서 사용 중 부족한 경우 다른 배열로
  복사하는 코드를 직접 구현해야한다.

- ArrayList 클래스는 자바에서 제공되는 객체 배열이 구현된 클래스로 여러 메소드와
  속성을 사용하여 객체 배열을 편리하게 관리 할 수 있다.

## 상속과 다형성

- 상속 : 상위 클래스는 하위 클래스 보다 일반적인 의미를 가지며
  하위 클래스는 상위 클래스 보다 구체적인 의미를 가지게 된다
  상위 클래스의 정보를 하위 클래스로 받아 오는것을 의미한다. 
  extends 로 사용한다.

- 상위 클래스의 인스턴스가 먼저 생성이 되고, 하위 클래스의 인스턴스가 생성된다.

- 업 캐스팅 : 상위 클래스 형으로 변수를 선언하고 하위 클래스 인스턴스를 
  생성할 수 있다. 하위 클래스는 상위 클래스의 타입을 내포하고 있으므로 상위 클래스로 묵시적 형 변환이 가능하다.

## 상속과 다형성 2

- 업 캐스팅 : 상위 클래스로의 묵시적 형 변환을 의미한다.
  상위 클래스 형으로 변수를 선언하고 하위 클래스 인스턴스를 생성할 수 있다.
  하위 클래스는 상위 클래스의 타입을 내포하고 있으므로 상위 클래스로의 묵시적
  형변환이 가능하다.

- 형 변환에서의 메모리 사용 : Customer vc = new VIPCustomer();
  VIPCustomer() 생성자의 호출로 인스턴스는 모두 생성 되었지만 타입이 Customer
  이므로 접근 할 수 있는 변수나 메소드는 Customer의 변수와 메소드이다.

- 메소드 오버라이딩 : 상위 클래스에 정의 된 메소드 중 하위 클래스와 기능이 맞지
  않거나 추가 기능이 필요한 경우 같은 이름과 매개변수로 하위 클래스에서 재정의 함.

- 가상 메소드 : 프로그램에서 어떤 객체의 변수나 메소드의 참조는 그 타입에 따라
  이루어지는데 가상 메소드의 경우는 타입과  상관없이 실제 생성된 인스턴스의 
  메소드가 호출 되는 원리이다.
 ex) Customer vc = new VIPCustomer();
      vc.calcPrice(10000);
      vc의 타입은 Customer 지만, 실제 생성된 인스턴스인 VIPCustomer 클래스의
      calcPrice() 메소드가 호출되는 것.

- 다형성 (polymorphism) : 하나의 코드가 여러가지 자료형으로 구현되어 실행 되는 것
  정보은닉, 상속과 더불어 객체지향 프로그래밍의 가장 큰 특징 중 하나이다.
  유연성, 재활용성, 유지보수성에 기본이 되는 특징.

- 하나의 클래스를 상속받은 여러 클래스가 있는 경우 각 클래스마다 같은 이름의
  서로 다른 메소드를 재정의 한다. 상위 클래스 타입으로 선언된 하나의 변수가 여러
  인스턴스에 대입되어 다양한 구현이 실행될 수 있다.
  